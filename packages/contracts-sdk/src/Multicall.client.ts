/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import {Addr, Binary, Call, CallOptional, AggregateResult, CallResult, BlockAggregateResult, ContractVersion} from "./types";
import {InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg} from "./Multicall.types";
export interface MulticallReadOnlyInterface {
  contractAddress: string;
  contractVersion: () => Promise<ContractVersion>;
  aggregate: ({
    queries
  }: {
    queries: Call[];
  }) => Promise<AggregateResult>;
  tryAggregate: ({
    includeCause,
    queries,
    requireSuccess
  }: {
    includeCause?: boolean;
    queries: Call[];
    requireSuccess?: boolean;
  }) => Promise<AggregateResult>;
  tryAggregateOptional: ({
    includeCause,
    queries
  }: {
    includeCause?: boolean;
    queries: CallOptional[];
  }) => Promise<AggregateResult>;
  blockAggregate: ({
    queries
  }: {
    queries: Call[];
  }) => Promise<BlockAggregateResult>;
  blockTryAggregate: ({
    includeCause,
    queries,
    requireSuccess
  }: {
    includeCause?: boolean;
    queries: Call[];
    requireSuccess?: boolean;
  }) => Promise<BlockAggregateResult>;
  blockTryAggregateOptional: ({
    includeCause,
    queries
  }: {
    includeCause?: boolean;
    queries: CallOptional[];
  }) => Promise<BlockAggregateResult>;
}
export class MulticallQueryClient implements MulticallReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractVersion = this.contractVersion.bind(this);
    this.aggregate = this.aggregate.bind(this);
    this.tryAggregate = this.tryAggregate.bind(this);
    this.tryAggregateOptional = this.tryAggregateOptional.bind(this);
    this.blockAggregate = this.blockAggregate.bind(this);
    this.blockTryAggregate = this.blockTryAggregate.bind(this);
    this.blockTryAggregateOptional = this.blockTryAggregateOptional.bind(this);
  }

  contractVersion = async (): Promise<ContractVersion> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_version: {}
    });
  };
  aggregate = async ({
    queries
  }: {
    queries: Call[];
  }): Promise<AggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      aggregate: {
        queries
      }
    });
  };
  tryAggregate = async ({
    includeCause,
    queries,
    requireSuccess
  }: {
    includeCause?: boolean;
    queries: Call[];
    requireSuccess?: boolean;
  }): Promise<AggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      try_aggregate: {
        include_cause: includeCause,
        queries,
        require_success: requireSuccess
      }
    });
  };
  tryAggregateOptional = async ({
    includeCause,
    queries
  }: {
    includeCause?: boolean;
    queries: CallOptional[];
  }): Promise<AggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      try_aggregate_optional: {
        include_cause: includeCause,
        queries
      }
    });
  };
  blockAggregate = async ({
    queries
  }: {
    queries: Call[];
  }): Promise<BlockAggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      block_aggregate: {
        queries
      }
    });
  };
  blockTryAggregate = async ({
    includeCause,
    queries,
    requireSuccess
  }: {
    includeCause?: boolean;
    queries: Call[];
    requireSuccess?: boolean;
  }): Promise<BlockAggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      block_try_aggregate: {
        include_cause: includeCause,
        queries,
        require_success: requireSuccess
      }
    });
  };
  blockTryAggregateOptional = async ({
    includeCause,
    queries
  }: {
    includeCause?: boolean;
    queries: CallOptional[];
  }): Promise<BlockAggregateResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      block_try_aggregate_optional: {
        include_cause: includeCause,
        queries
      }
    });
  };
}