/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Uint128, Binary, Addr, AssetInfo, Decimal, Cw20ReceiveMsg, Asset} from "./types";
import {InstantiateMsg, ExecuteMsg, OrderDirection, QueryMsg, OrderFilter, MigrateMsg, ContractInfoResponse, LastOrderIdResponse, OrderStatus, OrderResponse, OrderBookResponse, OrderBooksResponse, OrdersResponse, SimulateMarketOrderResponse, TickResponse, TicksResponse} from "./OraiswapOrderbook.types";
export interface OraiswapOrderbookReadOnlyInterface {
  contractAddress: string;
  contractInfo: () => Promise<ContractInfoResponse>;
  orderBook: ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }) => Promise<OrderBookResponse>;
  orderBooks: ({
    limit,
    orderBy,
    startAfter
  }: {
    limit?: number;
    orderBy?: number;
    startAfter?: number[];
  }) => Promise<OrderBooksResponse>;
  order: ({
    assetInfos,
    orderId
  }: {
    assetInfos: AssetInfo[];
    orderId: number;
  }) => Promise<OrderResponse>;
  orders: ({
    assetInfos,
    direction,
    filter,
    limit,
    orderBy,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    direction?: OrderDirection;
    filter: OrderFilter;
    limit?: number;
    orderBy?: number;
    startAfter?: number;
  }) => Promise<OrdersResponse>;
  tick: ({
    assetInfos,
    direction,
    price
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    price: Decimal;
  }) => Promise<TickResponse>;
  ticks: ({
    assetInfos,
    direction,
    end,
    limit,
    orderBy,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    end?: Decimal;
    limit?: number;
    orderBy?: number;
    startAfter?: Decimal;
  }) => Promise<TicksResponse>;
  lastOrderId: () => Promise<LastOrderIdResponse>;
  midPrice: ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }) => Promise<Decimal>;
  simulateMarketOrder: ({
    assetInfos,
    direction,
    offerAmount,
    slippage
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    offerAmount: Uint128;
    slippage?: Decimal;
  }) => Promise<SimulateMarketOrderResponse>;
}
export class OraiswapOrderbookQueryClient implements OraiswapOrderbookReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.contractInfo = this.contractInfo.bind(this);
    this.orderBook = this.orderBook.bind(this);
    this.orderBooks = this.orderBooks.bind(this);
    this.order = this.order.bind(this);
    this.orders = this.orders.bind(this);
    this.tick = this.tick.bind(this);
    this.ticks = this.ticks.bind(this);
    this.lastOrderId = this.lastOrderId.bind(this);
    this.midPrice = this.midPrice.bind(this);
    this.simulateMarketOrder = this.simulateMarketOrder.bind(this);
  }

  contractInfo = async (): Promise<ContractInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      contract_info: {}
    });
  };
  orderBook = async ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }): Promise<OrderBookResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      order_book: {
        asset_infos: assetInfos
      }
    });
  };
  orderBooks = async ({
    limit,
    orderBy,
    startAfter
  }: {
    limit?: number;
    orderBy?: number;
    startAfter?: number[];
  }): Promise<OrderBooksResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      order_books: {
        limit,
        order_by: orderBy,
        start_after: startAfter
      }
    });
  };
  order = async ({
    assetInfos,
    orderId
  }: {
    assetInfos: AssetInfo[];
    orderId: number;
  }): Promise<OrderResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      order: {
        asset_infos: assetInfos,
        order_id: orderId
      }
    });
  };
  orders = async ({
    assetInfos,
    direction,
    filter,
    limit,
    orderBy,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    direction?: OrderDirection;
    filter: OrderFilter;
    limit?: number;
    orderBy?: number;
    startAfter?: number;
  }): Promise<OrdersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      orders: {
        asset_infos: assetInfos,
        direction,
        filter,
        limit,
        order_by: orderBy,
        start_after: startAfter
      }
    });
  };
  tick = async ({
    assetInfos,
    direction,
    price
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    price: Decimal;
  }): Promise<TickResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tick: {
        asset_infos: assetInfos,
        direction,
        price
      }
    });
  };
  ticks = async ({
    assetInfos,
    direction,
    end,
    limit,
    orderBy,
    startAfter
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    end?: Decimal;
    limit?: number;
    orderBy?: number;
    startAfter?: Decimal;
  }): Promise<TicksResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      ticks: {
        asset_infos: assetInfos,
        direction,
        end,
        limit,
        order_by: orderBy,
        start_after: startAfter
      }
    });
  };
  lastOrderId = async (): Promise<LastOrderIdResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      last_order_id: {}
    });
  };
  midPrice = async ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }): Promise<Decimal> => {
    return this.client.queryContractSmart(this.contractAddress, {
      mid_price: {
        asset_infos: assetInfos
      }
    });
  };
  simulateMarketOrder = async ({
    assetInfos,
    direction,
    offerAmount,
    slippage
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    offerAmount: Uint128;
    slippage?: Decimal;
  }): Promise<SimulateMarketOrderResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      simulate_market_order: {
        asset_infos: assetInfos,
        direction,
        offer_amount: offerAmount,
        slippage
      }
    });
  };
}
export interface OraiswapOrderbookInterface extends OraiswapOrderbookReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  pause: (_fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  unpause: (_fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateAdmin: ({
    admin
  }: {
    admin: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    commissionRate,
    rewardAddress
  }: {
    commissionRate?: string;
    rewardAddress?: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOperator: ({
    operator
  }: {
    operator?: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createOrderBookPair: ({
    baseCoinInfo,
    minQuoteCoinAmount,
    quoteCoinInfo,
    refundThreshold,
    spread
  }: {
    baseCoinInfo: AssetInfo;
    minQuoteCoinAmount: Uint128;
    quoteCoinInfo: AssetInfo;
    refundThreshold?: Uint128;
    spread?: Decimal;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateOrderbookPair: ({
    assetInfos,
    minQuoteCoinAmount,
    refundThreshold,
    spread
  }: {
    assetInfos: AssetInfo[];
    minQuoteCoinAmount?: Uint128;
    refundThreshold?: Uint128;
    spread?: Decimal;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  submitOrder: ({
    assets,
    direction
  }: {
    assets: Asset[];
    direction: OrderDirection;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  submitMarketOrder: ({
    assetInfos,
    direction,
    slippage
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    slippage?: Decimal;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  cancelOrder: ({
    assetInfos,
    orderId
  }: {
    assetInfos: AssetInfo[];
    orderId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeOrderBookPair: ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawToken: ({
    asset
  }: {
    asset: Asset;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OraiswapOrderbookClient extends OraiswapOrderbookQueryClient implements OraiswapOrderbookInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.pause = this.pause.bind(this);
    this.unpause = this.unpause.bind(this);
    this.updateAdmin = this.updateAdmin.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateOperator = this.updateOperator.bind(this);
    this.createOrderBookPair = this.createOrderBookPair.bind(this);
    this.updateOrderbookPair = this.updateOrderbookPair.bind(this);
    this.submitOrder = this.submitOrder.bind(this);
    this.submitMarketOrder = this.submitMarketOrder.bind(this);
    this.cancelOrder = this.cancelOrder.bind(this);
    this.removeOrderBookPair = this.removeOrderBookPair.bind(this);
    this.withdrawToken = this.withdrawToken.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, _fee, _memo, _funds);
  };
  pause = async (_fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      pause: {}
    }, _fee, _memo, _funds);
  };
  unpause = async (_fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unpause: {}
    }, _fee, _memo, _funds);
  };
  updateAdmin = async ({
    admin
  }: {
    admin: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_admin: {
        admin
      }
    }, _fee, _memo, _funds);
  };
  updateConfig = async ({
    commissionRate,
    rewardAddress
  }: {
    commissionRate?: string;
    rewardAddress?: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        commission_rate: commissionRate,
        reward_address: rewardAddress
      }
    }, _fee, _memo, _funds);
  };
  updateOperator = async ({
    operator
  }: {
    operator?: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_operator: {
        operator
      }
    }, _fee, _memo, _funds);
  };
  createOrderBookPair = async ({
    baseCoinInfo,
    minQuoteCoinAmount,
    quoteCoinInfo,
    refundThreshold,
    spread
  }: {
    baseCoinInfo: AssetInfo;
    minQuoteCoinAmount: Uint128;
    quoteCoinInfo: AssetInfo;
    refundThreshold?: Uint128;
    spread?: Decimal;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_order_book_pair: {
        base_coin_info: baseCoinInfo,
        min_quote_coin_amount: minQuoteCoinAmount,
        quote_coin_info: quoteCoinInfo,
        refund_threshold: refundThreshold,
        spread
      }
    }, _fee, _memo, _funds);
  };
  updateOrderbookPair = async ({
    assetInfos,
    minQuoteCoinAmount,
    refundThreshold,
    spread
  }: {
    assetInfos: AssetInfo[];
    minQuoteCoinAmount?: Uint128;
    refundThreshold?: Uint128;
    spread?: Decimal;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_orderbook_pair: {
        asset_infos: assetInfos,
        min_quote_coin_amount: minQuoteCoinAmount,
        refund_threshold: refundThreshold,
        spread
      }
    }, _fee, _memo, _funds);
  };
  submitOrder = async ({
    assets,
    direction
  }: {
    assets: Asset[];
    direction: OrderDirection;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_order: {
        assets,
        direction
      }
    }, _fee, _memo, _funds);
  };
  submitMarketOrder = async ({
    assetInfos,
    direction,
    slippage
  }: {
    assetInfos: AssetInfo[];
    direction: OrderDirection;
    slippage?: Decimal;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      submit_market_order: {
        asset_infos: assetInfos,
        direction,
        slippage
      }
    }, _fee, _memo, _funds);
  };
  cancelOrder = async ({
    assetInfos,
    orderId
  }: {
    assetInfos: AssetInfo[];
    orderId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      cancel_order: {
        asset_infos: assetInfos,
        order_id: orderId
      }
    }, _fee, _memo, _funds);
  };
  removeOrderBookPair = async ({
    assetInfos
  }: {
    assetInfos: AssetInfo[];
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_order_book_pair: {
        asset_infos: assetInfos
      }
    }, _fee, _memo, _funds);
  };
  withdrawToken = async ({
    asset
  }: {
    asset: Asset;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_token: {
        asset
      }
    }, _fee, _memo, _funds);
  };
}