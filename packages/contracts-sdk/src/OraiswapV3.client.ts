/**
* This file was automatically generated by @oraichain/ts-codegen@0.35.9.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @oraichain/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import {Percentage, InstantiateMsg, ExecuteMsg, Addr, Liquidity, SqrtPrice, TokenAmount, Binary, Expiration, Timestamp, Uint64, AssetInfo, PoolKey, FeeTier, SwapHop, NftExtensionMsg, QueryMsg, MigrateMsg, FeeGrowth, AllNftInfoResponse, OwnerOfResponse, Approval, NftInfoResponse, Position, PositionIncentives, ArrayOfPosition, TokensResponse, ApprovedForAllResponse, Boolean, ArrayOfFeeTier, ArrayOfLiquidityTick, LiquidityTick, Uint32, NumTokensResponse, Pool, IncentiveRecord, ArrayOfPoolWithPoolKey, PoolWithPoolKey, Uint128, ArrayOfAsset, Asset, ArrayOfPositionTick, PositionTick, QuoteResult, Tick, TickIncentive, ArrayOfTupleOfUint16AndUint64} from "./OraiswapV3.types";
export interface OraiswapV3ReadOnlyInterface {
  contractAddress: string;
  admin: () => Promise<Addr>;
  protocolFee: () => Promise<Percentage>;
  position: ({
    index,
    ownerId
  }: {
    index: number;
    ownerId: Addr;
  }) => Promise<Position>;
  positions: ({
    limit,
    offset,
    ownerId
  }: {
    limit?: number;
    offset?: number;
    ownerId: Addr;
  }) => Promise<ArrayOfPosition>;
  allPosition: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Binary;
  }) => Promise<ArrayOfPosition>;
  feeTierExist: ({
    feeTier
  }: {
    feeTier: FeeTier;
  }) => Promise<Boolean>;
  pool: ({
    feeTier,
    token0,
    token1
  }: {
    feeTier: FeeTier;
    token0: string;
    token1: string;
  }) => Promise<Pool>;
  pools: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: PoolKey;
  }) => Promise<ArrayOfPoolWithPoolKey>;
  tick: ({
    index,
    key
  }: {
    index: number;
    key: PoolKey;
  }) => Promise<Tick>;
  isTickInitialized: ({
    index,
    key
  }: {
    index: number;
    key: PoolKey;
  }) => Promise<Boolean>;
  feeTiers: () => Promise<ArrayOfFeeTier>;
  positionTicks: ({
    offset,
    owner
  }: {
    offset: number;
    owner: Addr;
  }) => Promise<ArrayOfPositionTick>;
  userPositionAmount: ({
    owner
  }: {
    owner: Addr;
  }) => Promise<Uint32>;
  tickMap: ({
    lowerTickIndex,
    poolKey,
    upperTickIndex,
    xToY
  }: {
    lowerTickIndex: number;
    poolKey: PoolKey;
    upperTickIndex: number;
    xToY: boolean;
  }) => Promise<ArrayOfTupleOfUint16AndUint64>;
  liquidityTicks: ({
    poolKey,
    tickIndexes
  }: {
    poolKey: PoolKey;
    tickIndexes: number[];
  }) => Promise<ArrayOfLiquidityTick>;
  liquidityTicksAmount: ({
    lowerTick,
    poolKey,
    upperTick
  }: {
    lowerTick: number;
    poolKey: PoolKey;
    upperTick: number;
  }) => Promise<Uint32>;
  poolsForPair: ({
    token0,
    token1
  }: {
    token0: string;
    token1: string;
  }) => Promise<ArrayOfPoolWithPoolKey>;
  quote: ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount;
    byAmountIn: boolean;
    poolKey: PoolKey;
    sqrtPriceLimit: SqrtPrice;
    xToY: boolean;
  }) => Promise<QuoteResult>;
  quoteRoute: ({
    amountIn,
    swaps
  }: {
    amountIn: TokenAmount;
    swaps: SwapHop[];
  }) => Promise<TokenAmount>;
  numTokens: () => Promise<NumTokensResponse>;
  ownerOf: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: number;
  }) => Promise<OwnerOfResponse>;
  approvedForAll: ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: Addr;
    startAfter?: Addr;
  }) => Promise<ApprovedForAllResponse>;
  nftInfo: ({
    tokenId
  }: {
    tokenId: number;
  }) => Promise<NftInfoResponse>;
  allNftInfo: ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: number;
  }) => Promise<AllNftInfoResponse>;
  tokens: ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: Addr;
    startAfter?: number;
  }) => Promise<TokensResponse>;
  allTokens: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }) => Promise<TokensResponse>;
  positionIncentives: ({
    index,
    ownerId
  }: {
    index: number;
    ownerId: Addr;
  }) => Promise<ArrayOfAsset>;
  poolsByPoolKeys: ({
    poolKeys
  }: {
    poolKeys: PoolKey[];
  }) => Promise<ArrayOfPoolWithPoolKey>;
}
export class OraiswapV3QueryClient implements OraiswapV3ReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.admin = this.admin.bind(this);
    this.protocolFee = this.protocolFee.bind(this);
    this.position = this.position.bind(this);
    this.positions = this.positions.bind(this);
    this.allPosition = this.allPosition.bind(this);
    this.feeTierExist = this.feeTierExist.bind(this);
    this.pool = this.pool.bind(this);
    this.pools = this.pools.bind(this);
    this.tick = this.tick.bind(this);
    this.isTickInitialized = this.isTickInitialized.bind(this);
    this.feeTiers = this.feeTiers.bind(this);
    this.positionTicks = this.positionTicks.bind(this);
    this.userPositionAmount = this.userPositionAmount.bind(this);
    this.tickMap = this.tickMap.bind(this);
    this.liquidityTicks = this.liquidityTicks.bind(this);
    this.liquidityTicksAmount = this.liquidityTicksAmount.bind(this);
    this.poolsForPair = this.poolsForPair.bind(this);
    this.quote = this.quote.bind(this);
    this.quoteRoute = this.quoteRoute.bind(this);
    this.numTokens = this.numTokens.bind(this);
    this.ownerOf = this.ownerOf.bind(this);
    this.approvedForAll = this.approvedForAll.bind(this);
    this.nftInfo = this.nftInfo.bind(this);
    this.allNftInfo = this.allNftInfo.bind(this);
    this.tokens = this.tokens.bind(this);
    this.allTokens = this.allTokens.bind(this);
    this.positionIncentives = this.positionIncentives.bind(this);
    this.poolsByPoolKeys = this.poolsByPoolKeys.bind(this);
  }

  admin = async (): Promise<Addr> => {
    return this.client.queryContractSmart(this.contractAddress, {
      admin: {}
    });
  };
  protocolFee = async (): Promise<Percentage> => {
    return this.client.queryContractSmart(this.contractAddress, {
      protocol_fee: {}
    });
  };
  position = async ({
    index,
    ownerId
  }: {
    index: number;
    ownerId: Addr;
  }): Promise<Position> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position: {
        index,
        owner_id: ownerId
      }
    });
  };
  positions = async ({
    limit,
    offset,
    ownerId
  }: {
    limit?: number;
    offset?: number;
    ownerId: Addr;
  }): Promise<ArrayOfPosition> => {
    return this.client.queryContractSmart(this.contractAddress, {
      positions: {
        limit,
        offset,
        owner_id: ownerId
      }
    });
  };
  allPosition = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: Binary;
  }): Promise<ArrayOfPosition> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_position: {
        limit,
        start_after: startAfter
      }
    });
  };
  feeTierExist = async ({
    feeTier
  }: {
    feeTier: FeeTier;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_tier_exist: {
        fee_tier: feeTier
      }
    });
  };
  pool = async ({
    feeTier,
    token0,
    token1
  }: {
    feeTier: FeeTier;
    token0: string;
    token1: string;
  }): Promise<Pool> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pool: {
        fee_tier: feeTier,
        token_0: token0,
        token_1: token1
      }
    });
  };
  pools = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: PoolKey;
  }): Promise<ArrayOfPoolWithPoolKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools: {
        limit,
        start_after: startAfter
      }
    });
  };
  tick = async ({
    index,
    key
  }: {
    index: number;
    key: PoolKey;
  }): Promise<Tick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tick: {
        index,
        key
      }
    });
  };
  isTickInitialized = async ({
    index,
    key
  }: {
    index: number;
    key: PoolKey;
  }): Promise<Boolean> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_tick_initialized: {
        index,
        key
      }
    });
  };
  feeTiers = async (): Promise<ArrayOfFeeTier> => {
    return this.client.queryContractSmart(this.contractAddress, {
      fee_tiers: {}
    });
  };
  positionTicks = async ({
    offset,
    owner
  }: {
    offset: number;
    owner: Addr;
  }): Promise<ArrayOfPositionTick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_ticks: {
        offset,
        owner
      }
    });
  };
  userPositionAmount = async ({
    owner
  }: {
    owner: Addr;
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      user_position_amount: {
        owner
      }
    });
  };
  tickMap = async ({
    lowerTickIndex,
    poolKey,
    upperTickIndex,
    xToY
  }: {
    lowerTickIndex: number;
    poolKey: PoolKey;
    upperTickIndex: number;
    xToY: boolean;
  }): Promise<ArrayOfTupleOfUint16AndUint64> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tick_map: {
        lower_tick_index: lowerTickIndex,
        pool_key: poolKey,
        upper_tick_index: upperTickIndex,
        x_to_y: xToY
      }
    });
  };
  liquidityTicks = async ({
    poolKey,
    tickIndexes
  }: {
    poolKey: PoolKey;
    tickIndexes: number[];
  }): Promise<ArrayOfLiquidityTick> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity_ticks: {
        pool_key: poolKey,
        tick_indexes: tickIndexes
      }
    });
  };
  liquidityTicksAmount = async ({
    lowerTick,
    poolKey,
    upperTick
  }: {
    lowerTick: number;
    poolKey: PoolKey;
    upperTick: number;
  }): Promise<Uint32> => {
    return this.client.queryContractSmart(this.contractAddress, {
      liquidity_ticks_amount: {
        lower_tick: lowerTick,
        pool_key: poolKey,
        upper_tick: upperTick
      }
    });
  };
  poolsForPair = async ({
    token0,
    token1
  }: {
    token0: string;
    token1: string;
  }): Promise<ArrayOfPoolWithPoolKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools_for_pair: {
        token_0: token0,
        token_1: token1
      }
    });
  };
  quote = async ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount;
    byAmountIn: boolean;
    poolKey: PoolKey;
    sqrtPriceLimit: SqrtPrice;
    xToY: boolean;
  }): Promise<QuoteResult> => {
    return this.client.queryContractSmart(this.contractAddress, {
      quote: {
        amount,
        by_amount_in: byAmountIn,
        pool_key: poolKey,
        sqrt_price_limit: sqrtPriceLimit,
        x_to_y: xToY
      }
    });
  };
  quoteRoute = async ({
    amountIn,
    swaps
  }: {
    amountIn: TokenAmount;
    swaps: SwapHop[];
  }): Promise<TokenAmount> => {
    return this.client.queryContractSmart(this.contractAddress, {
      quote_route: {
        amount_in: amountIn,
        swaps
      }
    });
  };
  numTokens = async (): Promise<NumTokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      num_tokens: {}
    });
  };
  ownerOf = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: number;
  }): Promise<OwnerOfResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      owner_of: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  approvedForAll = async ({
    includeExpired,
    limit,
    owner,
    startAfter
  }: {
    includeExpired?: boolean;
    limit?: number;
    owner: Addr;
    startAfter?: Addr;
  }): Promise<ApprovedForAllResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      approved_for_all: {
        include_expired: includeExpired,
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  nftInfo = async ({
    tokenId
  }: {
    tokenId: number;
  }): Promise<NftInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      nft_info: {
        token_id: tokenId
      }
    });
  };
  allNftInfo = async ({
    includeExpired,
    tokenId
  }: {
    includeExpired?: boolean;
    tokenId: number;
  }): Promise<AllNftInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_nft_info: {
        include_expired: includeExpired,
        token_id: tokenId
      }
    });
  };
  tokens = async ({
    limit,
    owner,
    startAfter
  }: {
    limit?: number;
    owner: Addr;
    startAfter?: number;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      tokens: {
        limit,
        owner,
        start_after: startAfter
      }
    });
  };
  allTokens = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: number;
  }): Promise<TokensResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_tokens: {
        limit,
        start_after: startAfter
      }
    });
  };
  positionIncentives = async ({
    index,
    ownerId
  }: {
    index: number;
    ownerId: Addr;
  }): Promise<ArrayOfAsset> => {
    return this.client.queryContractSmart(this.contractAddress, {
      position_incentives: {
        index,
        owner_id: ownerId
      }
    });
  };
  poolsByPoolKeys = async ({
    poolKeys
  }: {
    poolKeys: PoolKey[];
  }): Promise<ArrayOfPoolWithPoolKey> => {
    return this.client.queryContractSmart(this.contractAddress, {
      pools_by_pool_keys: {
        pool_keys: poolKeys
      }
    });
  };
}
export interface OraiswapV3Interface extends OraiswapV3ReadOnlyInterface {
  contractAddress: string;
  sender: string;
  changeAdmin: ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  withdrawProtocolFee: ({
    poolKey
  }: {
    poolKey: PoolKey;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeProtocolFee: ({
    protocolFee
  }: {
    protocolFee: Percentage;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  changeFeeReceiver: ({
    feeReceiver,
    poolKey
  }: {
    feeReceiver: Addr;
    poolKey: PoolKey;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createPosition: ({
    liquidityDelta,
    lowerTick,
    poolKey,
    slippageLimitLower,
    slippageLimitUpper,
    upperTick
  }: {
    liquidityDelta: Liquidity;
    lowerTick: number;
    poolKey: PoolKey;
    slippageLimitLower: SqrtPrice;
    slippageLimitUpper: SqrtPrice;
    upperTick: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swap: ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount;
    byAmountIn: boolean;
    poolKey: PoolKey;
    sqrtPriceLimit: SqrtPrice;
    xToY: boolean;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  swapRoute: ({
    amountIn,
    expectedAmountOut,
    slippage,
    swaps
  }: {
    amountIn: TokenAmount;
    expectedAmountOut: TokenAmount;
    slippage: Percentage;
    swaps: SwapHop[];
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferPosition: ({
    index,
    receiver
  }: {
    index: number;
    receiver: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimFee: ({
    index
  }: {
    index: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removePosition: ({
    index
  }: {
    index: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createPool: ({
    feeTier,
    initSqrtPrice,
    initTick,
    token0,
    token1
  }: {
    feeTier: FeeTier;
    initSqrtPrice: SqrtPrice;
    initTick: number;
    token0: string;
    token1: string;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addFeeTier: ({
    feeTier
  }: {
    feeTier: FeeTier;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeFeeTier: ({
    feeTier
  }: {
    feeTier: FeeTier;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  transferNft: ({
    recipient,
    tokenId
  }: {
    recipient: Addr;
    tokenId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  mint: ({
    extension
  }: {
    extension: NftExtensionMsg;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  burn: ({
    tokenId
  }: {
    tokenId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  sendNft: ({
    contract,
    msg,
    tokenId
  }: {
    contract: Addr;
    msg?: Binary;
    tokenId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  approve: ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: Addr;
    tokenId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revoke: ({
    spender,
    tokenId
  }: {
    spender: Addr;
    tokenId: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  approveAll: ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  revokeAll: ({
    operator
  }: {
    operator: Addr;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  createIncentive: ({
    poolKey,
    rewardPerSec,
    rewardToken,
    startTimestamp,
    totalReward
  }: {
    poolKey: PoolKey;
    rewardPerSec: TokenAmount;
    rewardToken: AssetInfo;
    startTimestamp?: number;
    totalReward?: TokenAmount;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  updateIncentive: ({
    incentiveId,
    poolKey,
    remainingReward,
    rewardPerSec,
    startTimestamp
  }: {
    incentiveId: number;
    poolKey: PoolKey;
    remainingReward?: TokenAmount;
    rewardPerSec?: TokenAmount;
    startTimestamp?: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimIncentive: ({
    index
  }: {
    index: number;
  }, _fee?: number | StdFee | "auto", _memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class OraiswapV3Client extends OraiswapV3QueryClient implements OraiswapV3Interface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.changeAdmin = this.changeAdmin.bind(this);
    this.withdrawProtocolFee = this.withdrawProtocolFee.bind(this);
    this.changeProtocolFee = this.changeProtocolFee.bind(this);
    this.changeFeeReceiver = this.changeFeeReceiver.bind(this);
    this.createPosition = this.createPosition.bind(this);
    this.swap = this.swap.bind(this);
    this.swapRoute = this.swapRoute.bind(this);
    this.transferPosition = this.transferPosition.bind(this);
    this.claimFee = this.claimFee.bind(this);
    this.removePosition = this.removePosition.bind(this);
    this.createPool = this.createPool.bind(this);
    this.addFeeTier = this.addFeeTier.bind(this);
    this.removeFeeTier = this.removeFeeTier.bind(this);
    this.transferNft = this.transferNft.bind(this);
    this.mint = this.mint.bind(this);
    this.burn = this.burn.bind(this);
    this.sendNft = this.sendNft.bind(this);
    this.approve = this.approve.bind(this);
    this.revoke = this.revoke.bind(this);
    this.approveAll = this.approveAll.bind(this);
    this.revokeAll = this.revokeAll.bind(this);
    this.createIncentive = this.createIncentive.bind(this);
    this.updateIncentive = this.updateIncentive.bind(this);
    this.claimIncentive = this.claimIncentive.bind(this);
  }

  changeAdmin = async ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_admin: {
        new_admin: newAdmin
      }
    }, _fee, _memo, _funds);
  };
  withdrawProtocolFee = async ({
    poolKey
  }: {
    poolKey: PoolKey;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw_protocol_fee: {
        pool_key: poolKey
      }
    }, _fee, _memo, _funds);
  };
  changeProtocolFee = async ({
    protocolFee
  }: {
    protocolFee: Percentage;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_protocol_fee: {
        protocol_fee: protocolFee
      }
    }, _fee, _memo, _funds);
  };
  changeFeeReceiver = async ({
    feeReceiver,
    poolKey
  }: {
    feeReceiver: Addr;
    poolKey: PoolKey;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      change_fee_receiver: {
        fee_receiver: feeReceiver,
        pool_key: poolKey
      }
    }, _fee, _memo, _funds);
  };
  createPosition = async ({
    liquidityDelta,
    lowerTick,
    poolKey,
    slippageLimitLower,
    slippageLimitUpper,
    upperTick
  }: {
    liquidityDelta: Liquidity;
    lowerTick: number;
    poolKey: PoolKey;
    slippageLimitLower: SqrtPrice;
    slippageLimitUpper: SqrtPrice;
    upperTick: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_position: {
        liquidity_delta: liquidityDelta,
        lower_tick: lowerTick,
        pool_key: poolKey,
        slippage_limit_lower: slippageLimitLower,
        slippage_limit_upper: slippageLimitUpper,
        upper_tick: upperTick
      }
    }, _fee, _memo, _funds);
  };
  swap = async ({
    amount,
    byAmountIn,
    poolKey,
    sqrtPriceLimit,
    xToY
  }: {
    amount: TokenAmount;
    byAmountIn: boolean;
    poolKey: PoolKey;
    sqrtPriceLimit: SqrtPrice;
    xToY: boolean;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap: {
        amount,
        by_amount_in: byAmountIn,
        pool_key: poolKey,
        sqrt_price_limit: sqrtPriceLimit,
        x_to_y: xToY
      }
    }, _fee, _memo, _funds);
  };
  swapRoute = async ({
    amountIn,
    expectedAmountOut,
    slippage,
    swaps
  }: {
    amountIn: TokenAmount;
    expectedAmountOut: TokenAmount;
    slippage: Percentage;
    swaps: SwapHop[];
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      swap_route: {
        amount_in: amountIn,
        expected_amount_out: expectedAmountOut,
        slippage,
        swaps
      }
    }, _fee, _memo, _funds);
  };
  transferPosition = async ({
    index,
    receiver
  }: {
    index: number;
    receiver: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_position: {
        index,
        receiver
      }
    }, _fee, _memo, _funds);
  };
  claimFee = async ({
    index
  }: {
    index: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_fee: {
        index
      }
    }, _fee, _memo, _funds);
  };
  removePosition = async ({
    index
  }: {
    index: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_position: {
        index
      }
    }, _fee, _memo, _funds);
  };
  createPool = async ({
    feeTier,
    initSqrtPrice,
    initTick,
    token0,
    token1
  }: {
    feeTier: FeeTier;
    initSqrtPrice: SqrtPrice;
    initTick: number;
    token0: string;
    token1: string;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_pool: {
        fee_tier: feeTier,
        init_sqrt_price: initSqrtPrice,
        init_tick: initTick,
        token_0: token0,
        token_1: token1
      }
    }, _fee, _memo, _funds);
  };
  addFeeTier = async ({
    feeTier
  }: {
    feeTier: FeeTier;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_fee_tier: {
        fee_tier: feeTier
      }
    }, _fee, _memo, _funds);
  };
  removeFeeTier = async ({
    feeTier
  }: {
    feeTier: FeeTier;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_fee_tier: {
        fee_tier: feeTier
      }
    }, _fee, _memo, _funds);
  };
  transferNft = async ({
    recipient,
    tokenId
  }: {
    recipient: Addr;
    tokenId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_nft: {
        recipient,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  mint = async ({
    extension
  }: {
    extension: NftExtensionMsg;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      mint: {
        extension
      }
    }, _fee, _memo, _funds);
  };
  burn = async ({
    tokenId
  }: {
    tokenId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      burn: {
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  sendNft = async ({
    contract,
    msg,
    tokenId
  }: {
    contract: Addr;
    msg?: Binary;
    tokenId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      send_nft: {
        contract,
        msg,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  approve = async ({
    expires,
    spender,
    tokenId
  }: {
    expires?: Expiration;
    spender: Addr;
    tokenId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve: {
        expires,
        spender,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  revoke = async ({
    spender,
    tokenId
  }: {
    spender: Addr;
    tokenId: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke: {
        spender,
        token_id: tokenId
      }
    }, _fee, _memo, _funds);
  };
  approveAll = async ({
    expires,
    operator
  }: {
    expires?: Expiration;
    operator: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      approve_all: {
        expires,
        operator
      }
    }, _fee, _memo, _funds);
  };
  revokeAll = async ({
    operator
  }: {
    operator: Addr;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      revoke_all: {
        operator
      }
    }, _fee, _memo, _funds);
  };
  createIncentive = async ({
    poolKey,
    rewardPerSec,
    rewardToken,
    startTimestamp,
    totalReward
  }: {
    poolKey: PoolKey;
    rewardPerSec: TokenAmount;
    rewardToken: AssetInfo;
    startTimestamp?: number;
    totalReward?: TokenAmount;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      create_incentive: {
        pool_key: poolKey,
        reward_per_sec: rewardPerSec,
        reward_token: rewardToken,
        start_timestamp: startTimestamp,
        total_reward: totalReward
      }
    }, _fee, _memo, _funds);
  };
  updateIncentive = async ({
    incentiveId,
    poolKey,
    remainingReward,
    rewardPerSec,
    startTimestamp
  }: {
    incentiveId: number;
    poolKey: PoolKey;
    remainingReward?: TokenAmount;
    rewardPerSec?: TokenAmount;
    startTimestamp?: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_incentive: {
        incentive_id: incentiveId,
        pool_key: poolKey,
        remaining_reward: remainingReward,
        reward_per_sec: rewardPerSec,
        start_timestamp: startTimestamp
      }
    }, _fee, _memo, _funds);
  };
  claimIncentive = async ({
    index
  }: {
    index: number;
  }, _fee: number | StdFee | "auto" = "auto", _memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_incentive: {
        index
      }
    }, _fee, _memo, _funds);
  };
}