// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v5.27.1
// source: packages/oraiswap/src/universal_swap_memo.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface Memo {
  userSwap:
    | Memo_UserSwap
    | undefined;
  /** string because the minimum receive may be very high due to decimal points */
  minimumReceive: string;
  timeoutTimestamp: number;
  postSwapAction: Memo_PostAction | undefined;
  recoveryAddr: string;
}

/**
 * we dont need swap amount since it will be sent via cw20 or native, and we
 * use that
 */
export interface Memo_SwapExactAssetIn {
  operations: Memo_SwapOperation[];
}

export interface Memo_SmartSwapExactAssetIn {
  routes: Memo_Route[];
}

export interface Memo_Route {
  offerAmount: string;
  operations: Memo_SwapOperation[];
}

export interface Memo_SwapOperation {
  poolId: string;
  denomIn: string;
  denomOut: string;
}

/**
 * if none is provided -> error, if more than one attributes are provided ->
 * error
 */
export interface Memo_UserSwap {
  /**
   * or adapter name so that the smart router can redirect to the right swap
   * router.
   */
  swapVenueName: string;
  swapExactAssetIn?: Memo_SwapExactAssetIn | undefined;
  smartSwapExactAssetIn?: Memo_SmartSwapExactAssetIn | undefined;
}

/**
 * Can possibly have both? -> if both then always contract_call first then ibc
 * transfer
 */
export interface Memo_PostAction {
  ibcTransferMsg?: Memo_IbcTransfer | undefined;
  ibcWasmTransferMsg?: Memo_IbcWasmTransfer | undefined;
  contractCall?: Memo_ContractCall | undefined;
  transferMsg?: Memo_Transfer | undefined;
}

export interface Memo_IbcTransfer {
  sourceChannel: string;
  sourcePort: string;
  receiver: string;
  memo: string;
  recoverAddress: string;
}

export interface Memo_IbcWasmTransfer {
  /** / the local ibc endpoint you want to send tokens back on */
  localChannelId: string;
  /** can be 0x or bech32 */
  remoteAddress: string;
  /**
   * / remote denom so that we know what denom to filter when we query based on
   * / the asset info. Most likely be: oraib0x... or eth0x...
   */
  remoteDenom: string;
  /**
   * / How long the packet lives in seconds. If not specified, use
   * / default_timeout
   */
  timeout?:
    | number
    | undefined;
  /** / metadata of the transfer to suit the new fungible token transfer */
  memo?: string | undefined;
}

export interface Memo_ContractCall {
  contractAddress: string;
  msg: string;
}

export interface Memo_Transfer {
  toAddress: string;
}

function createBaseMemo(): Memo {
  return { userSwap: undefined, minimumReceive: "", timeoutTimestamp: 0, postSwapAction: undefined, recoveryAddr: "" };
}

export const Memo = {
  encode(message: Memo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userSwap !== undefined) {
      Memo_UserSwap.encode(message.userSwap, writer.uint32(10).fork()).ldelim();
    }
    if (message.minimumReceive !== "") {
      writer.uint32(18).string(message.minimumReceive);
    }
    if (message.timeoutTimestamp !== 0) {
      writer.uint32(24).uint64(message.timeoutTimestamp);
    }
    if (message.postSwapAction !== undefined) {
      Memo_PostAction.encode(message.postSwapAction, writer.uint32(34).fork()).ldelim();
    }
    if (message.recoveryAddr !== "") {
      writer.uint32(42).string(message.recoveryAddr);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userSwap = Memo_UserSwap.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minimumReceive = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeoutTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postSwapAction = Memo_PostAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recoveryAddr = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo {
    return {
      userSwap: isSet(object.userSwap) ? Memo_UserSwap.fromJSON(object.userSwap) : undefined,
      minimumReceive: isSet(object.minimumReceive) ? globalThis.String(object.minimumReceive) : "",
      timeoutTimestamp: isSet(object.timeoutTimestamp) ? globalThis.Number(object.timeoutTimestamp) : 0,
      postSwapAction: isSet(object.postSwapAction) ? Memo_PostAction.fromJSON(object.postSwapAction) : undefined,
      recoveryAddr: isSet(object.recoveryAddr) ? globalThis.String(object.recoveryAddr) : "",
    };
  },

  toJSON(message: Memo): unknown {
    const obj: any = {};
    if (message.userSwap !== undefined) {
      obj.userSwap = Memo_UserSwap.toJSON(message.userSwap);
    }
    if (message.minimumReceive !== "") {
      obj.minimumReceive = message.minimumReceive;
    }
    if (message.timeoutTimestamp !== 0) {
      obj.timeoutTimestamp = Math.round(message.timeoutTimestamp);
    }
    if (message.postSwapAction !== undefined) {
      obj.postSwapAction = Memo_PostAction.toJSON(message.postSwapAction);
    }
    if (message.recoveryAddr !== "") {
      obj.recoveryAddr = message.recoveryAddr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo>, I>>(base?: I): Memo {
    return Memo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo>, I>>(object: I): Memo {
    const message = createBaseMemo();
    message.userSwap = (object.userSwap !== undefined && object.userSwap !== null)
      ? Memo_UserSwap.fromPartial(object.userSwap)
      : undefined;
    message.minimumReceive = object.minimumReceive ?? "";
    message.timeoutTimestamp = object.timeoutTimestamp ?? 0;
    message.postSwapAction = (object.postSwapAction !== undefined && object.postSwapAction !== null)
      ? Memo_PostAction.fromPartial(object.postSwapAction)
      : undefined;
    message.recoveryAddr = object.recoveryAddr ?? "";
    return message;
  },
};

function createBaseMemo_SwapExactAssetIn(): Memo_SwapExactAssetIn {
  return { operations: [] };
}

export const Memo_SwapExactAssetIn = {
  encode(message: Memo_SwapExactAssetIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.operations) {
      Memo_SwapOperation.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SwapExactAssetIn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SwapExactAssetIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.operations.push(Memo_SwapOperation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SwapExactAssetIn {
    return {
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Memo_SwapOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Memo_SwapExactAssetIn): unknown {
    const obj: any = {};
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Memo_SwapOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SwapExactAssetIn>, I>>(base?: I): Memo_SwapExactAssetIn {
    return Memo_SwapExactAssetIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SwapExactAssetIn>, I>>(object: I): Memo_SwapExactAssetIn {
    const message = createBaseMemo_SwapExactAssetIn();
    message.operations = object.operations?.map((e) => Memo_SwapOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_SmartSwapExactAssetIn(): Memo_SmartSwapExactAssetIn {
  return { routes: [] };
}

export const Memo_SmartSwapExactAssetIn = {
  encode(message: Memo_SmartSwapExactAssetIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.routes) {
      Memo_Route.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SmartSwapExactAssetIn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SmartSwapExactAssetIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routes.push(Memo_Route.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SmartSwapExactAssetIn {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Memo_Route.fromJSON(e)) : [],
    };
  },

  toJSON(message: Memo_SmartSwapExactAssetIn): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Memo_Route.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SmartSwapExactAssetIn>, I>>(base?: I): Memo_SmartSwapExactAssetIn {
    return Memo_SmartSwapExactAssetIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SmartSwapExactAssetIn>, I>>(object: I): Memo_SmartSwapExactAssetIn {
    const message = createBaseMemo_SmartSwapExactAssetIn();
    message.routes = object.routes?.map((e) => Memo_Route.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_Route(): Memo_Route {
  return { offerAmount: "", operations: [] };
}

export const Memo_Route = {
  encode(message: Memo_Route, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offerAmount !== "") {
      writer.uint32(10).string(message.offerAmount);
    }
    for (const v of message.operations) {
      Memo_SwapOperation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_Route {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_Route();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offerAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operations.push(Memo_SwapOperation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_Route {
    return {
      offerAmount: isSet(object.offerAmount) ? globalThis.String(object.offerAmount) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Memo_SwapOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Memo_Route): unknown {
    const obj: any = {};
    if (message.offerAmount !== "") {
      obj.offerAmount = message.offerAmount;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Memo_SwapOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_Route>, I>>(base?: I): Memo_Route {
    return Memo_Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_Route>, I>>(object: I): Memo_Route {
    const message = createBaseMemo_Route();
    message.offerAmount = object.offerAmount ?? "";
    message.operations = object.operations?.map((e) => Memo_SwapOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_SwapOperation(): Memo_SwapOperation {
  return { poolId: "", denomIn: "", denomOut: "" };
}

export const Memo_SwapOperation = {
  encode(message: Memo_SwapOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.poolId !== "") {
      writer.uint32(10).string(message.poolId);
    }
    if (message.denomIn !== "") {
      writer.uint32(18).string(message.denomIn);
    }
    if (message.denomOut !== "") {
      writer.uint32(26).string(message.denomOut);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SwapOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SwapOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.poolId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.denomIn = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.denomOut = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SwapOperation {
    return {
      poolId: isSet(object.poolId) ? globalThis.String(object.poolId) : "",
      denomIn: isSet(object.denomIn) ? globalThis.String(object.denomIn) : "",
      denomOut: isSet(object.denomOut) ? globalThis.String(object.denomOut) : "",
    };
  },

  toJSON(message: Memo_SwapOperation): unknown {
    const obj: any = {};
    if (message.poolId !== "") {
      obj.poolId = message.poolId;
    }
    if (message.denomIn !== "") {
      obj.denomIn = message.denomIn;
    }
    if (message.denomOut !== "") {
      obj.denomOut = message.denomOut;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SwapOperation>, I>>(base?: I): Memo_SwapOperation {
    return Memo_SwapOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SwapOperation>, I>>(object: I): Memo_SwapOperation {
    const message = createBaseMemo_SwapOperation();
    message.poolId = object.poolId ?? "";
    message.denomIn = object.denomIn ?? "";
    message.denomOut = object.denomOut ?? "";
    return message;
  },
};

function createBaseMemo_UserSwap(): Memo_UserSwap {
  return { swapVenueName: "", swapExactAssetIn: undefined, smartSwapExactAssetIn: undefined };
}

export const Memo_UserSwap = {
  encode(message: Memo_UserSwap, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.swapVenueName !== "") {
      writer.uint32(10).string(message.swapVenueName);
    }
    if (message.swapExactAssetIn !== undefined) {
      Memo_SwapExactAssetIn.encode(message.swapExactAssetIn, writer.uint32(18).fork()).ldelim();
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      Memo_SmartSwapExactAssetIn.encode(message.smartSwapExactAssetIn, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_UserSwap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_UserSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.swapVenueName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.swapExactAssetIn = Memo_SwapExactAssetIn.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_UserSwap {
    return {
      swapVenueName: isSet(object.swapVenueName) ? globalThis.String(object.swapVenueName) : "",
      swapExactAssetIn: isSet(object.swapExactAssetIn)
        ? Memo_SwapExactAssetIn.fromJSON(object.swapExactAssetIn)
        : undefined,
      smartSwapExactAssetIn: isSet(object.smartSwapExactAssetIn)
        ? Memo_SmartSwapExactAssetIn.fromJSON(object.smartSwapExactAssetIn)
        : undefined,
    };
  },

  toJSON(message: Memo_UserSwap): unknown {
    const obj: any = {};
    if (message.swapVenueName !== "") {
      obj.swapVenueName = message.swapVenueName;
    }
    if (message.swapExactAssetIn !== undefined) {
      obj.swapExactAssetIn = Memo_SwapExactAssetIn.toJSON(message.swapExactAssetIn);
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      obj.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.toJSON(message.smartSwapExactAssetIn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_UserSwap>, I>>(base?: I): Memo_UserSwap {
    return Memo_UserSwap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_UserSwap>, I>>(object: I): Memo_UserSwap {
    const message = createBaseMemo_UserSwap();
    message.swapVenueName = object.swapVenueName ?? "";
    message.swapExactAssetIn = (object.swapExactAssetIn !== undefined && object.swapExactAssetIn !== null)
      ? Memo_SwapExactAssetIn.fromPartial(object.swapExactAssetIn)
      : undefined;
    message.smartSwapExactAssetIn =
      (object.smartSwapExactAssetIn !== undefined && object.smartSwapExactAssetIn !== null)
        ? Memo_SmartSwapExactAssetIn.fromPartial(object.smartSwapExactAssetIn)
        : undefined;
    return message;
  },
};

function createBaseMemo_PostAction(): Memo_PostAction {
  return { ibcTransferMsg: undefined, ibcWasmTransferMsg: undefined, contractCall: undefined, transferMsg: undefined };
}

export const Memo_PostAction = {
  encode(message: Memo_PostAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ibcTransferMsg !== undefined) {
      Memo_IbcTransfer.encode(message.ibcTransferMsg, writer.uint32(10).fork()).ldelim();
    }
    if (message.ibcWasmTransferMsg !== undefined) {
      Memo_IbcWasmTransfer.encode(message.ibcWasmTransferMsg, writer.uint32(18).fork()).ldelim();
    }
    if (message.contractCall !== undefined) {
      Memo_ContractCall.encode(message.contractCall, writer.uint32(26).fork()).ldelim();
    }
    if (message.transferMsg !== undefined) {
      Memo_Transfer.encode(message.transferMsg, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_PostAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_PostAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ibcTransferMsg = Memo_IbcTransfer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.ibcWasmTransferMsg = Memo_IbcWasmTransfer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.contractCall = Memo_ContractCall.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transferMsg = Memo_Transfer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_PostAction {
    return {
      ibcTransferMsg: isSet(object.ibcTransferMsg) ? Memo_IbcTransfer.fromJSON(object.ibcTransferMsg) : undefined,
      ibcWasmTransferMsg: isSet(object.ibcWasmTransferMsg)
        ? Memo_IbcWasmTransfer.fromJSON(object.ibcWasmTransferMsg)
        : undefined,
      contractCall: isSet(object.contractCall) ? Memo_ContractCall.fromJSON(object.contractCall) : undefined,
      transferMsg: isSet(object.transferMsg) ? Memo_Transfer.fromJSON(object.transferMsg) : undefined,
    };
  },

  toJSON(message: Memo_PostAction): unknown {
    const obj: any = {};
    if (message.ibcTransferMsg !== undefined) {
      obj.ibcTransferMsg = Memo_IbcTransfer.toJSON(message.ibcTransferMsg);
    }
    if (message.ibcWasmTransferMsg !== undefined) {
      obj.ibcWasmTransferMsg = Memo_IbcWasmTransfer.toJSON(message.ibcWasmTransferMsg);
    }
    if (message.contractCall !== undefined) {
      obj.contractCall = Memo_ContractCall.toJSON(message.contractCall);
    }
    if (message.transferMsg !== undefined) {
      obj.transferMsg = Memo_Transfer.toJSON(message.transferMsg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_PostAction>, I>>(base?: I): Memo_PostAction {
    return Memo_PostAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_PostAction>, I>>(object: I): Memo_PostAction {
    const message = createBaseMemo_PostAction();
    message.ibcTransferMsg = (object.ibcTransferMsg !== undefined && object.ibcTransferMsg !== null)
      ? Memo_IbcTransfer.fromPartial(object.ibcTransferMsg)
      : undefined;
    message.ibcWasmTransferMsg = (object.ibcWasmTransferMsg !== undefined && object.ibcWasmTransferMsg !== null)
      ? Memo_IbcWasmTransfer.fromPartial(object.ibcWasmTransferMsg)
      : undefined;
    message.contractCall = (object.contractCall !== undefined && object.contractCall !== null)
      ? Memo_ContractCall.fromPartial(object.contractCall)
      : undefined;
    message.transferMsg = (object.transferMsg !== undefined && object.transferMsg !== null)
      ? Memo_Transfer.fromPartial(object.transferMsg)
      : undefined;
    return message;
  },
};

function createBaseMemo_IbcTransfer(): Memo_IbcTransfer {
  return { sourceChannel: "", sourcePort: "", receiver: "", memo: "", recoverAddress: "" };
}

export const Memo_IbcTransfer = {
  encode(message: Memo_IbcTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceChannel !== "") {
      writer.uint32(10).string(message.sourceChannel);
    }
    if (message.sourcePort !== "") {
      writer.uint32(18).string(message.sourcePort);
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    if (message.recoverAddress !== "") {
      writer.uint32(42).string(message.recoverAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_IbcTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_IbcTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceChannel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourcePort = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recoverAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_IbcTransfer {
    return {
      sourceChannel: isSet(object.sourceChannel) ? globalThis.String(object.sourceChannel) : "",
      sourcePort: isSet(object.sourcePort) ? globalThis.String(object.sourcePort) : "",
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      recoverAddress: isSet(object.recoverAddress) ? globalThis.String(object.recoverAddress) : "",
    };
  },

  toJSON(message: Memo_IbcTransfer): unknown {
    const obj: any = {};
    if (message.sourceChannel !== "") {
      obj.sourceChannel = message.sourceChannel;
    }
    if (message.sourcePort !== "") {
      obj.sourcePort = message.sourcePort;
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.recoverAddress !== "") {
      obj.recoverAddress = message.recoverAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_IbcTransfer>, I>>(base?: I): Memo_IbcTransfer {
    return Memo_IbcTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_IbcTransfer>, I>>(object: I): Memo_IbcTransfer {
    const message = createBaseMemo_IbcTransfer();
    message.sourceChannel = object.sourceChannel ?? "";
    message.sourcePort = object.sourcePort ?? "";
    message.receiver = object.receiver ?? "";
    message.memo = object.memo ?? "";
    message.recoverAddress = object.recoverAddress ?? "";
    return message;
  },
};

function createBaseMemo_IbcWasmTransfer(): Memo_IbcWasmTransfer {
  return { localChannelId: "", remoteAddress: "", remoteDenom: "", timeout: undefined, memo: undefined };
}

export const Memo_IbcWasmTransfer = {
  encode(message: Memo_IbcWasmTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.localChannelId !== "") {
      writer.uint32(10).string(message.localChannelId);
    }
    if (message.remoteAddress !== "") {
      writer.uint32(18).string(message.remoteAddress);
    }
    if (message.remoteDenom !== "") {
      writer.uint32(26).string(message.remoteDenom);
    }
    if (message.timeout !== undefined) {
      writer.uint32(32).uint64(message.timeout);
    }
    if (message.memo !== undefined) {
      writer.uint32(42).string(message.memo);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_IbcWasmTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_IbcWasmTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.localChannelId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.remoteAddress = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.remoteDenom = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.timeout = longToNumber(reader.uint64() as Long);
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.memo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_IbcWasmTransfer {
    return {
      localChannelId: isSet(object.localChannelId) ? globalThis.String(object.localChannelId) : "",
      remoteAddress: isSet(object.remoteAddress) ? globalThis.String(object.remoteAddress) : "",
      remoteDenom: isSet(object.remoteDenom) ? globalThis.String(object.remoteDenom) : "",
      timeout: isSet(object.timeout) ? globalThis.Number(object.timeout) : undefined,
      memo: isSet(object.memo) ? globalThis.String(object.memo) : undefined,
    };
  },

  toJSON(message: Memo_IbcWasmTransfer): unknown {
    const obj: any = {};
    if (message.localChannelId !== "") {
      obj.localChannelId = message.localChannelId;
    }
    if (message.remoteAddress !== "") {
      obj.remoteAddress = message.remoteAddress;
    }
    if (message.remoteDenom !== "") {
      obj.remoteDenom = message.remoteDenom;
    }
    if (message.timeout !== undefined) {
      obj.timeout = Math.round(message.timeout);
    }
    if (message.memo !== undefined) {
      obj.memo = message.memo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_IbcWasmTransfer>, I>>(base?: I): Memo_IbcWasmTransfer {
    return Memo_IbcWasmTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_IbcWasmTransfer>, I>>(object: I): Memo_IbcWasmTransfer {
    const message = createBaseMemo_IbcWasmTransfer();
    message.localChannelId = object.localChannelId ?? "";
    message.remoteAddress = object.remoteAddress ?? "";
    message.remoteDenom = object.remoteDenom ?? "";
    message.timeout = object.timeout ?? undefined;
    message.memo = object.memo ?? undefined;
    return message;
  },
};

function createBaseMemo_ContractCall(): Memo_ContractCall {
  return { contractAddress: "", msg: "" };
}

export const Memo_ContractCall = {
  encode(message: Memo_ContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_ContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_ContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_ContractCall {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: Memo_ContractCall): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_ContractCall>, I>>(base?: I): Memo_ContractCall {
    return Memo_ContractCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_ContractCall>, I>>(object: I): Memo_ContractCall {
    const message = createBaseMemo_ContractCall();
    message.contractAddress = object.contractAddress ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

function createBaseMemo_Transfer(): Memo_Transfer {
  return { toAddress: "" };
}

export const Memo_Transfer = {
  encode(message: Memo_Transfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.toAddress !== "") {
      writer.uint32(10).string(message.toAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_Transfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_Transfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.toAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_Transfer {
    return { toAddress: isSet(object.toAddress) ? globalThis.String(object.toAddress) : "" };
  },

  toJSON(message: Memo_Transfer): unknown {
    const obj: any = {};
    if (message.toAddress !== "") {
      obj.toAddress = message.toAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_Transfer>, I>>(base?: I): Memo_Transfer {
    return Memo_Transfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_Transfer>, I>>(object: I): Memo_Transfer {
    const message = createBaseMemo_Transfer();
    message.toAddress = object.toAddress ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
