// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.1
//   protoc               v4.25.3
// source: packages/universal-swap/src/proto/universal-swap-memo.proto

/* eslint-disable */
import * as _m0 from "protobufjs/minimal";
import Long = require("long");

export const protobufPackage = "";

export interface Memo {
  userSwap:
    | Memo_UserSwap
    | undefined;
  /** string because the minimum receive may be very high due to decimal points */
  minimumReceive: string;
  timeoutTimestamp: number;
  postSwapAction: Memo_PostAction | undefined;
  recoveryAddr: string;
  swapExactAssetIn?: Memo_SwapExactAssetIn | undefined;
  smartSwapExactAssetIn?: Memo_SmartSwapExactAssetIn | undefined;
}

export interface Memo_SwapExactAssetIn {
  offerAmount: string;
  operations: Memo_SwapOperation[];
}

export interface Memo_SmartSwapExactAssetIn {
  routes: Memo_Route[];
}

export interface Memo_Route {
  offerAmount: string;
  operations: Memo_SwapOperation[];
}

export interface Memo_SwapOperation {
  poolId: Memo_PoolId | undefined;
}

export interface Memo_FeeTier {
  fee: number;
  tickSpacing: number;
}

export interface Memo_PoolKey {
  tokenX: Memo_AssetInfo | undefined;
  tokenY:
    | Memo_AssetInfo
    | undefined;
  /** if it's v2 -> no fee tier */
  feeTier?: Memo_FeeTier | undefined;
}

export interface Memo_AssetInfo {
  denom: string;
  /** This would help us parse between native and contract addr */
  isNative: boolean;
}

export interface Memo_PoolId {
  poolKey:
    | Memo_PoolKey
    | undefined;
  /** we can use this to create v2 swap operation as well */
  xToY: boolean;
}

/** if none is provided -> error, if more than one attributes are provided -> error */
export interface Memo_UserSwap {
  swapExactAssetIn?: Memo_SwapExactAssetIn | undefined;
  smartSwapExactAssetIn?: Memo_SmartSwapExactAssetIn | undefined;
}

/** Can possibly have both? -> if both then always contract_call first then ibc transfer */
export interface Memo_PostAction {
  ibcTransferMsg?: Memo_IbcTransfer | undefined;
  contractCall?: Memo_ContractCall | undefined;
}

export interface Memo_IbcTransfer {
  sourceChannel: string;
  sourcePort: string;
  receiver: string;
  memo: string;
  recoverAddress: string;
}

export interface Memo_ContractCall {
  contractAddress: string;
  msg: string;
}

function createBaseMemo(): Memo {
  return {
    userSwap: undefined,
    minimumReceive: "",
    timeoutTimestamp: 0,
    postSwapAction: undefined,
    recoveryAddr: "",
    swapExactAssetIn: undefined,
    smartSwapExactAssetIn: undefined,
  };
}

export const Memo = {
  encode(message: Memo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.userSwap !== undefined) {
      Memo_UserSwap.encode(message.userSwap, writer.uint32(10).fork()).ldelim();
    }
    if (message.minimumReceive !== "") {
      writer.uint32(18).string(message.minimumReceive);
    }
    if (message.timeoutTimestamp !== 0) {
      writer.uint32(24).uint64(message.timeoutTimestamp);
    }
    if (message.postSwapAction !== undefined) {
      Memo_PostAction.encode(message.postSwapAction, writer.uint32(34).fork()).ldelim();
    }
    if (message.recoveryAddr !== "") {
      writer.uint32(42).string(message.recoveryAddr);
    }
    if (message.swapExactAssetIn !== undefined) {
      Memo_SwapExactAssetIn.encode(message.swapExactAssetIn, writer.uint32(50).fork()).ldelim();
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      Memo_SmartSwapExactAssetIn.encode(message.smartSwapExactAssetIn, writer.uint32(58).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.userSwap = Memo_UserSwap.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.minimumReceive = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.timeoutTimestamp = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.postSwapAction = Memo_PostAction.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recoveryAddr = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.swapExactAssetIn = Memo_SwapExactAssetIn.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo {
    return {
      userSwap: isSet(object.userSwap) ? Memo_UserSwap.fromJSON(object.userSwap) : undefined,
      minimumReceive: isSet(object.minimumReceive) ? globalThis.String(object.minimumReceive) : "",
      timeoutTimestamp: isSet(object.timeoutTimestamp) ? globalThis.Number(object.timeoutTimestamp) : 0,
      postSwapAction: isSet(object.postSwapAction) ? Memo_PostAction.fromJSON(object.postSwapAction) : undefined,
      recoveryAddr: isSet(object.recoveryAddr) ? globalThis.String(object.recoveryAddr) : "",
      swapExactAssetIn: isSet(object.swapExactAssetIn)
        ? Memo_SwapExactAssetIn.fromJSON(object.swapExactAssetIn)
        : undefined,
      smartSwapExactAssetIn: isSet(object.smartSwapExactAssetIn)
        ? Memo_SmartSwapExactAssetIn.fromJSON(object.smartSwapExactAssetIn)
        : undefined,
    };
  },

  toJSON(message: Memo): unknown {
    const obj: any = {};
    if (message.userSwap !== undefined) {
      obj.userSwap = Memo_UserSwap.toJSON(message.userSwap);
    }
    if (message.minimumReceive !== "") {
      obj.minimumReceive = message.minimumReceive;
    }
    if (message.timeoutTimestamp !== 0) {
      obj.timeoutTimestamp = Math.round(message.timeoutTimestamp);
    }
    if (message.postSwapAction !== undefined) {
      obj.postSwapAction = Memo_PostAction.toJSON(message.postSwapAction);
    }
    if (message.recoveryAddr !== "") {
      obj.recoveryAddr = message.recoveryAddr;
    }
    if (message.swapExactAssetIn !== undefined) {
      obj.swapExactAssetIn = Memo_SwapExactAssetIn.toJSON(message.swapExactAssetIn);
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      obj.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.toJSON(message.smartSwapExactAssetIn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo>, I>>(base?: I): Memo {
    return Memo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo>, I>>(object: I): Memo {
    const message = createBaseMemo();
    message.userSwap = (object.userSwap !== undefined && object.userSwap !== null)
      ? Memo_UserSwap.fromPartial(object.userSwap)
      : undefined;
    message.minimumReceive = object.minimumReceive ?? "";
    message.timeoutTimestamp = object.timeoutTimestamp ?? 0;
    message.postSwapAction = (object.postSwapAction !== undefined && object.postSwapAction !== null)
      ? Memo_PostAction.fromPartial(object.postSwapAction)
      : undefined;
    message.recoveryAddr = object.recoveryAddr ?? "";
    message.swapExactAssetIn = (object.swapExactAssetIn !== undefined && object.swapExactAssetIn !== null)
      ? Memo_SwapExactAssetIn.fromPartial(object.swapExactAssetIn)
      : undefined;
    message.smartSwapExactAssetIn =
      (object.smartSwapExactAssetIn !== undefined && object.smartSwapExactAssetIn !== null)
        ? Memo_SmartSwapExactAssetIn.fromPartial(object.smartSwapExactAssetIn)
        : undefined;
    return message;
  },
};

function createBaseMemo_SwapExactAssetIn(): Memo_SwapExactAssetIn {
  return { offerAmount: "", operations: [] };
}

export const Memo_SwapExactAssetIn = {
  encode(message: Memo_SwapExactAssetIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offerAmount !== "") {
      writer.uint32(10).string(message.offerAmount);
    }
    for (const v of message.operations) {
      Memo_SwapOperation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SwapExactAssetIn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SwapExactAssetIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offerAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operations.push(Memo_SwapOperation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SwapExactAssetIn {
    return {
      offerAmount: isSet(object.offerAmount) ? globalThis.String(object.offerAmount) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Memo_SwapOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Memo_SwapExactAssetIn): unknown {
    const obj: any = {};
    if (message.offerAmount !== "") {
      obj.offerAmount = message.offerAmount;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Memo_SwapOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SwapExactAssetIn>, I>>(base?: I): Memo_SwapExactAssetIn {
    return Memo_SwapExactAssetIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SwapExactAssetIn>, I>>(object: I): Memo_SwapExactAssetIn {
    const message = createBaseMemo_SwapExactAssetIn();
    message.offerAmount = object.offerAmount ?? "";
    message.operations = object.operations?.map((e) => Memo_SwapOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_SmartSwapExactAssetIn(): Memo_SmartSwapExactAssetIn {
  return { routes: [] };
}

export const Memo_SmartSwapExactAssetIn = {
  encode(message: Memo_SmartSwapExactAssetIn, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    for (const v of message.routes) {
      Memo_Route.encode(v!, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SmartSwapExactAssetIn {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SmartSwapExactAssetIn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.routes.push(Memo_Route.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SmartSwapExactAssetIn {
    return {
      routes: globalThis.Array.isArray(object?.routes) ? object.routes.map((e: any) => Memo_Route.fromJSON(e)) : [],
    };
  },

  toJSON(message: Memo_SmartSwapExactAssetIn): unknown {
    const obj: any = {};
    if (message.routes?.length) {
      obj.routes = message.routes.map((e) => Memo_Route.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SmartSwapExactAssetIn>, I>>(base?: I): Memo_SmartSwapExactAssetIn {
    return Memo_SmartSwapExactAssetIn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SmartSwapExactAssetIn>, I>>(object: I): Memo_SmartSwapExactAssetIn {
    const message = createBaseMemo_SmartSwapExactAssetIn();
    message.routes = object.routes?.map((e) => Memo_Route.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_Route(): Memo_Route {
  return { offerAmount: "", operations: [] };
}

export const Memo_Route = {
  encode(message: Memo_Route, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.offerAmount !== "") {
      writer.uint32(10).string(message.offerAmount);
    }
    for (const v of message.operations) {
      Memo_SwapOperation.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_Route {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_Route();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.offerAmount = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operations.push(Memo_SwapOperation.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_Route {
    return {
      offerAmount: isSet(object.offerAmount) ? globalThis.String(object.offerAmount) : "",
      operations: globalThis.Array.isArray(object?.operations)
        ? object.operations.map((e: any) => Memo_SwapOperation.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Memo_Route): unknown {
    const obj: any = {};
    if (message.offerAmount !== "") {
      obj.offerAmount = message.offerAmount;
    }
    if (message.operations?.length) {
      obj.operations = message.operations.map((e) => Memo_SwapOperation.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_Route>, I>>(base?: I): Memo_Route {
    return Memo_Route.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_Route>, I>>(object: I): Memo_Route {
    const message = createBaseMemo_Route();
    message.offerAmount = object.offerAmount ?? "";
    message.operations = object.operations?.map((e) => Memo_SwapOperation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMemo_SwapOperation(): Memo_SwapOperation {
  return { poolId: undefined };
}

export const Memo_SwapOperation = {
  encode(message: Memo_SwapOperation, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.poolId !== undefined) {
      Memo_PoolId.encode(message.poolId, writer.uint32(10).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_SwapOperation {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_SwapOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.poolId = Memo_PoolId.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_SwapOperation {
    return { poolId: isSet(object.poolId) ? Memo_PoolId.fromJSON(object.poolId) : undefined };
  },

  toJSON(message: Memo_SwapOperation): unknown {
    const obj: any = {};
    if (message.poolId !== undefined) {
      obj.poolId = Memo_PoolId.toJSON(message.poolId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_SwapOperation>, I>>(base?: I): Memo_SwapOperation {
    return Memo_SwapOperation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_SwapOperation>, I>>(object: I): Memo_SwapOperation {
    const message = createBaseMemo_SwapOperation();
    message.poolId = (object.poolId !== undefined && object.poolId !== null)
      ? Memo_PoolId.fromPartial(object.poolId)
      : undefined;
    return message;
  },
};

function createBaseMemo_FeeTier(): Memo_FeeTier {
  return { fee: 0, tickSpacing: 0 };
}

export const Memo_FeeTier = {
  encode(message: Memo_FeeTier, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.fee !== 0) {
      writer.uint32(8).uint64(message.fee);
    }
    if (message.tickSpacing !== 0) {
      writer.uint32(16).uint32(message.tickSpacing);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_FeeTier {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_FeeTier();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.fee = longToNumber(reader.uint64() as Long);
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.tickSpacing = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_FeeTier {
    return {
      fee: isSet(object.fee) ? globalThis.Number(object.fee) : 0,
      tickSpacing: isSet(object.tickSpacing) ? globalThis.Number(object.tickSpacing) : 0,
    };
  },

  toJSON(message: Memo_FeeTier): unknown {
    const obj: any = {};
    if (message.fee !== 0) {
      obj.fee = Math.round(message.fee);
    }
    if (message.tickSpacing !== 0) {
      obj.tickSpacing = Math.round(message.tickSpacing);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_FeeTier>, I>>(base?: I): Memo_FeeTier {
    return Memo_FeeTier.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_FeeTier>, I>>(object: I): Memo_FeeTier {
    const message = createBaseMemo_FeeTier();
    message.fee = object.fee ?? 0;
    message.tickSpacing = object.tickSpacing ?? 0;
    return message;
  },
};

function createBaseMemo_PoolKey(): Memo_PoolKey {
  return { tokenX: undefined, tokenY: undefined, feeTier: undefined };
}

export const Memo_PoolKey = {
  encode(message: Memo_PoolKey, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.tokenX !== undefined) {
      Memo_AssetInfo.encode(message.tokenX, writer.uint32(10).fork()).ldelim();
    }
    if (message.tokenY !== undefined) {
      Memo_AssetInfo.encode(message.tokenY, writer.uint32(18).fork()).ldelim();
    }
    if (message.feeTier !== undefined) {
      Memo_FeeTier.encode(message.feeTier, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_PoolKey {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_PoolKey();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tokenX = Memo_AssetInfo.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.tokenY = Memo_AssetInfo.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.feeTier = Memo_FeeTier.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_PoolKey {
    return {
      tokenX: isSet(object.tokenX) ? Memo_AssetInfo.fromJSON(object.tokenX) : undefined,
      tokenY: isSet(object.tokenY) ? Memo_AssetInfo.fromJSON(object.tokenY) : undefined,
      feeTier: isSet(object.feeTier) ? Memo_FeeTier.fromJSON(object.feeTier) : undefined,
    };
  },

  toJSON(message: Memo_PoolKey): unknown {
    const obj: any = {};
    if (message.tokenX !== undefined) {
      obj.tokenX = Memo_AssetInfo.toJSON(message.tokenX);
    }
    if (message.tokenY !== undefined) {
      obj.tokenY = Memo_AssetInfo.toJSON(message.tokenY);
    }
    if (message.feeTier !== undefined) {
      obj.feeTier = Memo_FeeTier.toJSON(message.feeTier);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_PoolKey>, I>>(base?: I): Memo_PoolKey {
    return Memo_PoolKey.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_PoolKey>, I>>(object: I): Memo_PoolKey {
    const message = createBaseMemo_PoolKey();
    message.tokenX = (object.tokenX !== undefined && object.tokenX !== null)
      ? Memo_AssetInfo.fromPartial(object.tokenX)
      : undefined;
    message.tokenY = (object.tokenY !== undefined && object.tokenY !== null)
      ? Memo_AssetInfo.fromPartial(object.tokenY)
      : undefined;
    message.feeTier = (object.feeTier !== undefined && object.feeTier !== null)
      ? Memo_FeeTier.fromPartial(object.feeTier)
      : undefined;
    return message;
  },
};

function createBaseMemo_AssetInfo(): Memo_AssetInfo {
  return { denom: "", isNative: false };
}

export const Memo_AssetInfo = {
  encode(message: Memo_AssetInfo, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.isNative !== false) {
      writer.uint32(16).bool(message.isNative);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_AssetInfo {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_AssetInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.isNative = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_AssetInfo {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      isNative: isSet(object.isNative) ? globalThis.Boolean(object.isNative) : false,
    };
  },

  toJSON(message: Memo_AssetInfo): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.isNative !== false) {
      obj.isNative = message.isNative;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_AssetInfo>, I>>(base?: I): Memo_AssetInfo {
    return Memo_AssetInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_AssetInfo>, I>>(object: I): Memo_AssetInfo {
    const message = createBaseMemo_AssetInfo();
    message.denom = object.denom ?? "";
    message.isNative = object.isNative ?? false;
    return message;
  },
};

function createBaseMemo_PoolId(): Memo_PoolId {
  return { poolKey: undefined, xToY: false };
}

export const Memo_PoolId = {
  encode(message: Memo_PoolId, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.poolKey !== undefined) {
      Memo_PoolKey.encode(message.poolKey, writer.uint32(10).fork()).ldelim();
    }
    if (message.xToY !== false) {
      writer.uint32(16).bool(message.xToY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_PoolId {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_PoolId();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.poolKey = Memo_PoolKey.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.xToY = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_PoolId {
    return {
      poolKey: isSet(object.poolKey) ? Memo_PoolKey.fromJSON(object.poolKey) : undefined,
      xToY: isSet(object.xToY) ? globalThis.Boolean(object.xToY) : false,
    };
  },

  toJSON(message: Memo_PoolId): unknown {
    const obj: any = {};
    if (message.poolKey !== undefined) {
      obj.poolKey = Memo_PoolKey.toJSON(message.poolKey);
    }
    if (message.xToY !== false) {
      obj.xToY = message.xToY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_PoolId>, I>>(base?: I): Memo_PoolId {
    return Memo_PoolId.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_PoolId>, I>>(object: I): Memo_PoolId {
    const message = createBaseMemo_PoolId();
    message.poolKey = (object.poolKey !== undefined && object.poolKey !== null)
      ? Memo_PoolKey.fromPartial(object.poolKey)
      : undefined;
    message.xToY = object.xToY ?? false;
    return message;
  },
};

function createBaseMemo_UserSwap(): Memo_UserSwap {
  return { swapExactAssetIn: undefined, smartSwapExactAssetIn: undefined };
}

export const Memo_UserSwap = {
  encode(message: Memo_UserSwap, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.swapExactAssetIn !== undefined) {
      Memo_SwapExactAssetIn.encode(message.swapExactAssetIn, writer.uint32(10).fork()).ldelim();
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      Memo_SmartSwapExactAssetIn.encode(message.smartSwapExactAssetIn, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_UserSwap {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_UserSwap();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.swapExactAssetIn = Memo_SwapExactAssetIn.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_UserSwap {
    return {
      swapExactAssetIn: isSet(object.swapExactAssetIn)
        ? Memo_SwapExactAssetIn.fromJSON(object.swapExactAssetIn)
        : undefined,
      smartSwapExactAssetIn: isSet(object.smartSwapExactAssetIn)
        ? Memo_SmartSwapExactAssetIn.fromJSON(object.smartSwapExactAssetIn)
        : undefined,
    };
  },

  toJSON(message: Memo_UserSwap): unknown {
    const obj: any = {};
    if (message.swapExactAssetIn !== undefined) {
      obj.swapExactAssetIn = Memo_SwapExactAssetIn.toJSON(message.swapExactAssetIn);
    }
    if (message.smartSwapExactAssetIn !== undefined) {
      obj.smartSwapExactAssetIn = Memo_SmartSwapExactAssetIn.toJSON(message.smartSwapExactAssetIn);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_UserSwap>, I>>(base?: I): Memo_UserSwap {
    return Memo_UserSwap.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_UserSwap>, I>>(object: I): Memo_UserSwap {
    const message = createBaseMemo_UserSwap();
    message.swapExactAssetIn = (object.swapExactAssetIn !== undefined && object.swapExactAssetIn !== null)
      ? Memo_SwapExactAssetIn.fromPartial(object.swapExactAssetIn)
      : undefined;
    message.smartSwapExactAssetIn =
      (object.smartSwapExactAssetIn !== undefined && object.smartSwapExactAssetIn !== null)
        ? Memo_SmartSwapExactAssetIn.fromPartial(object.smartSwapExactAssetIn)
        : undefined;
    return message;
  },
};

function createBaseMemo_PostAction(): Memo_PostAction {
  return { ibcTransferMsg: undefined, contractCall: undefined };
}

export const Memo_PostAction = {
  encode(message: Memo_PostAction, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.ibcTransferMsg !== undefined) {
      Memo_IbcTransfer.encode(message.ibcTransferMsg, writer.uint32(10).fork()).ldelim();
    }
    if (message.contractCall !== undefined) {
      Memo_ContractCall.encode(message.contractCall, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_PostAction {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_PostAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.ibcTransferMsg = Memo_IbcTransfer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.contractCall = Memo_ContractCall.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_PostAction {
    return {
      ibcTransferMsg: isSet(object.ibcTransferMsg) ? Memo_IbcTransfer.fromJSON(object.ibcTransferMsg) : undefined,
      contractCall: isSet(object.contractCall) ? Memo_ContractCall.fromJSON(object.contractCall) : undefined,
    };
  },

  toJSON(message: Memo_PostAction): unknown {
    const obj: any = {};
    if (message.ibcTransferMsg !== undefined) {
      obj.ibcTransferMsg = Memo_IbcTransfer.toJSON(message.ibcTransferMsg);
    }
    if (message.contractCall !== undefined) {
      obj.contractCall = Memo_ContractCall.toJSON(message.contractCall);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_PostAction>, I>>(base?: I): Memo_PostAction {
    return Memo_PostAction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_PostAction>, I>>(object: I): Memo_PostAction {
    const message = createBaseMemo_PostAction();
    message.ibcTransferMsg = (object.ibcTransferMsg !== undefined && object.ibcTransferMsg !== null)
      ? Memo_IbcTransfer.fromPartial(object.ibcTransferMsg)
      : undefined;
    message.contractCall = (object.contractCall !== undefined && object.contractCall !== null)
      ? Memo_ContractCall.fromPartial(object.contractCall)
      : undefined;
    return message;
  },
};

function createBaseMemo_IbcTransfer(): Memo_IbcTransfer {
  return { sourceChannel: "", sourcePort: "", receiver: "", memo: "", recoverAddress: "" };
}

export const Memo_IbcTransfer = {
  encode(message: Memo_IbcTransfer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.sourceChannel !== "") {
      writer.uint32(10).string(message.sourceChannel);
    }
    if (message.sourcePort !== "") {
      writer.uint32(18).string(message.sourcePort);
    }
    if (message.receiver !== "") {
      writer.uint32(26).string(message.receiver);
    }
    if (message.memo !== "") {
      writer.uint32(34).string(message.memo);
    }
    if (message.recoverAddress !== "") {
      writer.uint32(42).string(message.recoverAddress);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_IbcTransfer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_IbcTransfer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceChannel = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.sourcePort = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.receiver = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.memo = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recoverAddress = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_IbcTransfer {
    return {
      sourceChannel: isSet(object.sourceChannel) ? globalThis.String(object.sourceChannel) : "",
      sourcePort: isSet(object.sourcePort) ? globalThis.String(object.sourcePort) : "",
      receiver: isSet(object.receiver) ? globalThis.String(object.receiver) : "",
      memo: isSet(object.memo) ? globalThis.String(object.memo) : "",
      recoverAddress: isSet(object.recoverAddress) ? globalThis.String(object.recoverAddress) : "",
    };
  },

  toJSON(message: Memo_IbcTransfer): unknown {
    const obj: any = {};
    if (message.sourceChannel !== "") {
      obj.sourceChannel = message.sourceChannel;
    }
    if (message.sourcePort !== "") {
      obj.sourcePort = message.sourcePort;
    }
    if (message.receiver !== "") {
      obj.receiver = message.receiver;
    }
    if (message.memo !== "") {
      obj.memo = message.memo;
    }
    if (message.recoverAddress !== "") {
      obj.recoverAddress = message.recoverAddress;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_IbcTransfer>, I>>(base?: I): Memo_IbcTransfer {
    return Memo_IbcTransfer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_IbcTransfer>, I>>(object: I): Memo_IbcTransfer {
    const message = createBaseMemo_IbcTransfer();
    message.sourceChannel = object.sourceChannel ?? "";
    message.sourcePort = object.sourcePort ?? "";
    message.receiver = object.receiver ?? "";
    message.memo = object.memo ?? "";
    message.recoverAddress = object.recoverAddress ?? "";
    return message;
  },
};

function createBaseMemo_ContractCall(): Memo_ContractCall {
  return { contractAddress: "", msg: "" };
}

export const Memo_ContractCall = {
  encode(message: Memo_ContractCall, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.contractAddress !== "") {
      writer.uint32(10).string(message.contractAddress);
    }
    if (message.msg !== "") {
      writer.uint32(18).string(message.msg);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Memo_ContractCall {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMemo_ContractCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.contractAddress = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.msg = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Memo_ContractCall {
    return {
      contractAddress: isSet(object.contractAddress) ? globalThis.String(object.contractAddress) : "",
      msg: isSet(object.msg) ? globalThis.String(object.msg) : "",
    };
  },

  toJSON(message: Memo_ContractCall): unknown {
    const obj: any = {};
    if (message.contractAddress !== "") {
      obj.contractAddress = message.contractAddress;
    }
    if (message.msg !== "") {
      obj.msg = message.msg;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Memo_ContractCall>, I>>(base?: I): Memo_ContractCall {
    return Memo_ContractCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Memo_ContractCall>, I>>(object: I): Memo_ContractCall {
    const message = createBaseMemo_ContractCall();
    message.contractAddress = object.contractAddress ?? "";
    message.msg = object.msg ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
